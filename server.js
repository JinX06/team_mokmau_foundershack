require('dotenv').config();

const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const mongoose = require('mongoose');
// Vertex AI and helpers
const { GoogleAuth } = require('google-auth-library');
const fetch = global.fetch || require('node-fetch');

let sharp;
try {
  sharp = require('sharp');
} catch (e) {
  console.warn('ℹ️ Optional dependency not found: sharp. Install with `npm i sharp` to enable thumbnails.');
}

const app = express();
const PORT = process.env.PORT || 3000;

/* ------------------------- Vertex AI config ------------------------- */
const VERTEX_PROJECT = process.env.GCP_PROJECT || process.env.PROJECT_ID || '';
const VERTEX_REGION = process.env.VERTEX_REGION || process.env.REGION || 'us-central1';
const VERTEX_ENDPOINT_ID = process.env.VERTEX_ENDPOINT_ID || '';

/* -------------------- System Instructions (Prompt) ------------------ */
const STYLE_SYSTEM_PROMPT = `You are an assistant that receives student submissions and uses them to establish a profile for the student's typical writing or coding style. Your role is two-fold:

Step 1: Initial Submission (Training Mode)

When given a student's first submission, perform the following tasks:

Extract and save the key stylistic patterns of the content, including:

Vocabulary richness and complexity

Sentence structure and flow

Tone, formality, and phrasing (for writing)

Code formatting conventions, naming patterns, and indentation (for code)

Do not evaluate for AI content at this stage. The goal is to register the student's natural style for future comparisons.

Store this style profile for comparison with future submissions.

Step 2: Future Submission (Comparison Mode)

When analyzing subsequent submissions, compare the new file with the student's previous submission(s). Assess for the following:

1. Style Drift Detection

Has the student’s tone, complexity, or code structure significantly changed?

Are there unnatural shifts in vocabulary usage, sentence length, indentation, or logic structure?

2. AI-Generated Content Detection

Evaluate for signs of AI-generated content using these signals:

Highly structured or generic language

Overuse of transitional phrases

Lack of personalization or context-specific details

Repetitive sentence structure

Abnormal jump in code/comment quality or formatting

3. Consistency Check

Are the themes, language, or coding patterns consistent with past submissions?
Response Format:

The response will include:

AI Usage Percentage: A percentage indicating how much of the student's submission appears to be generated by AI.

Hidden Evidence: The reasoning behind the AI detection (evidence, patterns, and analysis), which will only be shown to the educator and not to the student.

{
  "isAIContent": "partial",
  "aiUsageScore": 65,
  "confidenceLevel": "medium",
  "styleDeviationDetected": true,
  "evidence": [
    "Vocabulary complexity rose from Grade 9 to postgraduate level.",
    "Code indentation became perfectly uniform, inconsistent with past submissions."
  ],
  "linguisticFeatures": {
    "avgSentenceLength": 22,
    "formalityLevel": "high academic",
    "vocabularyShift": "intermediate → advanced",
    "repetitionPattern": "low variation, repetitive phrasing"
  },
  "codeAnalysis": {
    "commentingStyle": "extensive inline comments, previously absent",
    "indentationPattern": "4-space uniform (past work inconsistent)",
    "variableNaming": "now descriptive and camelCase, previously short lowercase"
  },
  "comparisonToPastWork": {
    "toneShift": "casual → formal",
    "complexityShift": "basic → advanced",
    "formattingShift": "messy → polished"
  },
  "scoringBreakdown": {
    "linguisticDeviation": 25,
    "codeDeviation": 18,
    "genericPatterns": 15,
    "repetitionAndFlow": 7
  },
  "aiUsageBreakdown": {
    "linguistic": 60,
    "coding": 70,
    "overall": 65
  },
  "suggestions": [
    "Ask student to reproduce part of the code live.",
    "Check with plagiarism databases.",
    "Review progression over multiple submissions before concluding."
  ],
  "metadata": {
    "submissionID": "12345",
    "studentID": "67890",
    "detectedAt": "2025-08-17T01:23:45Z",
    "detectedBy": "AIContentChecker-v2.2"
  }
}`;

/* ------------------------- URL helper ------------------------- */
const BASE_URL = process.env.BASE_URL || null; // e.g., 'https://your-domain.com'
function absUrl(req, path) {
  if (BASE_URL) return new URL(path, BASE_URL).toString();
  // fallback to current request host/proto (localhost in dev)
  return `${req.protocol}://${req.get('host')}${path}`;
}
// Set BASE_URL in .env (e.g., https://api.myapp.com) so links resolve to your remote host instead of localhost.

/* ------------------------- MongoDB connection ------------------------- */
/* Local-first MongoDB connection (defaults to localhost) */
const MONGO_URI =
  process.env.MONGO_URI ||
  'mongodb://127.0.0.1:27017/gotcha_dev';

mongoose
  .connect(MONGO_URI)
  .then(() => console.log('✅ MongoDB connected'))
  .catch((err) => {
    console.error('❌ MongoDB connection error:', err.message);
    process.exit(1);
  });

mongoose.connection.once('open', async () => {
  try {
    console.log('DB name:', mongoose.connection.name);
    console.log('User collection:', mongoose.connection.collection('Login_Collection').collectionName);
    const count = await mongoose.connection.collection('Login_Collection').countDocuments();
    const sample = await mongoose.connection.collection('Login_Collection').findOne({}, { projection: { username: 1, userType: 1, password: 1 } });
    console.log('Users count:', count);
    console.log('Sample user:', sample);
  } catch (e) {
    console.error('Startup debug failed:', e.message);
  }
});

/* ----------------------------- Models -------------------------------- */
/* Exact-match schema: do NOT transform values (no lowercase/trim on save) */
const userSchema = new mongoose.Schema(
  {
    username: { type: String, required: true, index: true },
    password: { type: String, required: true },
    userType: { type: String, required: true, enum: ['student', 'teacher'], index: true },
  },
  { timestamps: true }
);

/* Force the collection name to match your Atlas collection exactly */
const User = mongoose.model('User', userSchema, 'Login_Collection');

/* Optional: File model for saving uploaded file bytes to MongoDB */
const fileSchema = new mongoose.Schema(
  {
    filename: String,
    mimetype: String,
    size: Number,
    data: Buffer, // raw bytes
  },
  { timestamps: true }
);
const File = mongoose.model('File', fileSchema, 'Uploaded_Files');

/* --------------------- Student Style Profile Model --------------------- */
const studentProfileSchema = new mongoose.Schema({
  studentId: { type: String, index: true },
  features: { type: Object, default: {} },
  createdAt: { type: Date, default: Date.now }
});
const StudentProfile = mongoose.model('StudentProfile', studentProfileSchema, 'Student_Profiles');

/* ------------------------------ Middleware --------------------------- */
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static(path.join(__dirname, 'public')));
app.engine('html', require('ejs').renderFile);
app.set('view engine', 'html');
app.set('views', path.join(__dirname, 'views'));

/* --------------------- Feature Extraction Helpers --------------------- */
function tokenizeWords(text) {
  return (text || '').toLowerCase().match(/[a-zA-Z']+/g) || [];
}
function essayFeaturesFromText(text) {
  const words = tokenizeWords(text);
  const sentences = (text.match(/[.!?]+\s+/g) || []).length + 1;
  const chars = (text || '').length;
  const avgWordLen = words.length ? words.join('').length / words.length : 0;
  const unique = new Set(words).size;
  const ttr = words.length ? unique / words.length : 0;
  const punctRatio = chars ? ((text.match(/[.,;:!?]/g) || []).length / chars) : 0;
  const capsRatio = chars ? ((text.match(/[A-Z]/g) || []).length / chars) : 0;
  const stop = new Set(['the','and','of','to','a','in','that','it','is','was','i','for','on','you','with','as','at','be']);
  const stopFrac = words.length ? words.filter(w => stop.has(w)).length / words.length : 0;
  return {
    word_count: words.length,
    sentence_count: sentences,
    avg_word_len: Number(avgWordLen.toFixed(3)),
    type_token_ratio: Number(ttr.toFixed(3)),
    punctuation_ratio: Number(punctRatio.toFixed(4)),
    capital_ratio: Number(capsRatio.toFixed(4)),
    stopword_frac: Number(stopFrac.toFixed(3)),
    // placeholders for features your model expects
    perplexity: 50,
    burstiness: 0.2
  };
}
function codeFeaturesFromText(text) {
  const lines = (text || '').split(/\r?\n/);
  const loc = lines.length;
  const blanks = lines.filter(l => !l.trim()).length;
  const comments = lines.filter(l => l.trim().startsWith('#') || l.trim().startsWith('//') || l.trim().startsWith('/*')).length;
  const words = (text.match(/[A-Za-z_][A-Za-z0-9_]*/g) || []);
  const identifiers = words.filter(w => /[A-Za-z_][A-Za-z0-9_]*/.test(w));
  const avgIdLen = identifiers.length ? identifiers.join('').length / identifiers.length : 0;
  const camel = identifiers.filter(w => /[a-z]+[A-Z][A-Za-z0-9]*/.test(w)).length;
  const snake = identifiers.filter(w => /[a-z]+_[a-z0-9_]+/.test(w)).length;
  const depth = (text.match(/\{[^\}]*\}/g) || []).length + (text.match(/\(.*\)/g) || []).length;
  const imports = (text.match(/^(import|from)\b/mg) || []).length + (text.match(/^#include\b/mg) || []).length;
  return {
    language: 'Python',
    variable_naming_style: camel > snake ? 'camelCase' : 'snake_case',
    loc,
    comment_ratio: loc ? comments/loc : 0,
    blank_line_ratio: loc ? blanks/loc : 0,
    avg_identifier_len: Number(avgIdLen.toFixed(2)),
    functions: (text.match(/\bdef\b|function\b/g) || []).length,
    classes: (text.match(/\bclass\b/g) || []).length,
    cyclomatic_proxy: (text.match(/\bif\b|\bfor\b|\bwhile\b|\bcase\b|\?\:/g) || []).length,
    import_count: imports,
    stdlib_import_ratio: 0.6,
    camel_fraction: identifiers.length ? camel/identifiers.length : 0,
    snake_fraction: identifiers.length ? snake/identifiers.length : 0,
    nesting_depth: depth
  };
}

/* ------------------- Vertex Prediction Helper ------------------- */
async function vertexPredict(instance) {
  if (!VERTEX_PROJECT || !VERTEX_ENDPOINT_ID) {
    throw new Error('Vertex config missing: set GCP_PROJECT and VERTEX_ENDPOINT_ID in .env');
  }
  const url = `https://${VERTEX_REGION}-aiplatform.googleapis.com/v1/projects/${VERTEX_PROJECT}/locations/${VERTEX_REGION}/endpoints/${VERTEX_ENDPOINT_ID}:predict`;
  const auth = new GoogleAuth({ scopes: ['https://www.googleapis.com/auth/cloud-platform'] });
  const client = await auth.getClient();
  const token = await client.getAccessToken();
  const body = { instances: [instance] };
  const r = await fetch(url, {
    method: 'POST',
    headers: { 'Authorization': `Bearer ${token.token || token}`, 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  });
  if (!r.ok) {
    const t = await r.text();
    throw new Error(`Vertex predict failed ${r.status}: ${t}`);
  }
  return r.json();
}

/* ------------------------- File upload (multer) ---------------------- */
/* If you want to store bytes in Mongo, use memoryStorage (gives req.file.buffer) */
const upload = multer({ storage: multer.memoryStorage() });

/* -------------------------------- Routes ----------------------------- */

/* ------------------------------ Prediction UI ------------------------------ */
app.get('/predict', async (_req, res) => {
  try {
    const docs = await File.find({}, { filename: 1, mimetype: 1, size: 1, createdAt: 1 }).sort({ createdAt: -1 }).limit(200).lean();
    const rows = docs.map(d => `
      <tr>
        <td><input type="radio" name="fileId" value="${d._id}" required></td>
        <td>${d.filename || ''}</td>
        <td>${d.mimetype || ''}</td>
        <td>${d.size || 0}</td>
        <td>${new Date(d.createdAt).toLocaleString()}</td>
      </tr>
    `).join('');

    res.send(`
      <html>
        <head><title>Vertex Predict (Manual)</title></head>
        <body style="font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding:20px;">
          <h2>Select a file and run prediction</h2>
          <form method="POST" action="/predict/run">
            <div style="margin:8px 0;">
              <label>Content type: 
                <select name="contentType">
                  <option value="essay">Essay / text</option>
                  <option value="code">Code</option>
                </select>
              </label>
            </div>
            <div style="margin:8px 0;">
              <label>Mode: 
                <select name="mode">
                  <option value="baseline">Baseline (register style)</option>
                  <option value="compare">Compare to existing</option>
                </select>
              </label>
              <label style="margin-left:12px;">Student ID: <input name="studentId" required></label>
            </div>
            <table border="1" cellpadding="6" cellspacing="0">
              <thead><tr><th></th><th>filename</th><th>mimetype</th><th>size</th><th>createdAt</th></tr></thead>
              <tbody>${rows}</tbody>
            </table>
            <div style="margin-top:12px;"><button type="submit">Run</button> <a href="/predict/prompt" target="_blank">view system instructions</a></div>
          </form>
        </body>
      </html>
    `);
  } catch (e) {
    console.error('GET /predict error', e);
    res.status(500).send('Server error');
  }
});

app.get('/predict/prompt', (_req, res) => {
  res.set('Content-Type', 'text/plain');
  res.send(STYLE_SYSTEM_PROMPT);
});

app.post('/predict/run', async (req, res) => {
  try {
    const { fileId, contentType, mode, studentId } = req.body || {};
    if (!fileId || !contentType || !mode || !studentId) return res.status(400).send('Missing fields');

    const doc = await File.findById(fileId);
    if (!doc) return res.status(404).send('File not found');
    const buf = Buffer.isBuffer(doc.data) ? doc.data : Buffer.from(doc.data);
    const text = buf.toString('utf8');

    // Extract features
    const features = contentType === 'code' ? codeFeaturesFromText(text) : essayFeaturesFromText(text);

    // Baseline storage / comparison
    let baseline = await StudentProfile.findOne({ studentId }).lean();
    let evidence = [];
    if (mode === 'baseline' || !baseline) {
      await StudentProfile.updateOne(
        { studentId },
        { studentId, features },
        { upsert: true }
      );
      baseline = { studentId, features };
      evidence.push('Baseline registered for student.');
    } else {
      // simple drift signals for the demo
      const keys = Object.keys(features);
      keys.forEach(k => {
        const a = Number(features[k]);
        const b = Number(baseline.features[k]);
        if (!isNaN(a) && !isNaN(b)) {
          const diff = Math.abs(a - b);
          if (diff > (Math.abs(b) * 0.5 + 0.1)) {
            evidence.push(`Feature '${k}' drifted: old=${b} new=${a}`);
          }
        }
      });
    }

    // Call Vertex endpoint (AutoML Tabular) with the tabular instance
    const vertexResp = await vertexPredict(features);
    const pred = (vertexResp.predictions && vertexResp.predictions[0]) || {};

    // Try to infer AI score from AutoML output
    let aiUsageScore = 0;
    if (Array.isArray(pred.scores) && Array.isArray(pred.displayNames)) {
      const aiIdx = pred.displayNames.findIndex(n => /ai|AI/i.test(n) || /assisted/i.test(n));
      if (aiIdx >= 0) aiUsageScore = Math.round((pred.scores[aiIdx] || 0) * 100);
      else if (pred.scores.length) aiUsageScore = Math.round(Math.max(...pred.scores) * 100);
    }

    const isAIContent = aiUsageScore >= 80 ? 'likely' : aiUsageScore >= 40 ? 'partial' : 'unlikely';
    const confidenceLevel = aiUsageScore >= 75 ? 'high' : aiUsageScore >= 40 ? 'medium' : 'low';

    const out = {
      isAIContent,
      aiUsageScore,
      confidenceLevel,
      styleDeviationDetected: evidence.length > 1,
      evidence,
      featuresUsed: features,
      promptUsed: STYLE_SYSTEM_PROMPT.slice(0, 2000) + (STYLE_SYSTEM_PROMPT.length > 2000 ? '…' : ''),
      rawVertex: pred,
      metadata: {
        fileId: String(doc._id),
        studentId,
        modelEndpoint: VERTEX_ENDPOINT_ID,
        detectedAt: new Date().toISOString()
      }
    };

    res.set('Content-Type', 'application/json');
    res.send(JSON.stringify(out, null, 2));
  } catch (e) {
    console.error('POST /predict/run error', e);
    res.status(500).send('Server error: ' + e.message);
  }
});
app.get('/', (_req, res) => res.render('index'));
app.get('/login', (_req, res) => res.render('login'));
app.get('/about_us', (_req, res) => res.render('about_us'));
app.get('/plan_pricing', (_req, res) => res.render('plan_pricing'));
app.get('/signup', (_req, res) => res.render('signup'));

/**
 * Login (EXACT MATCH)
 * No regex, no normalization.
 * If your DB has weird spaces/punctuation, exact match will fail—clean the data first.
 */
app.post('/login', async (req, res) => {
  try {
    const { username, password, userType } = req.body;
    console.log('POST /login body:', req.body);

    if (!username || !password || !userType) {
      return res
        .status(400)
        .send('<h1>Missing fields</h1><a href="/login">Back</a>');
    }

    // Exact find: must match DB values exactly (case/spacing included)
    console.log('Querying with EXACT match:', { username, userType });
    const user = await User.findOne({ username, userType }).lean();
    console.log('Query result user:', user);

    if (!user) {
      console.log('User not found:', { username, userType });
      return res
        .status(401)
        .send('<h1>User not found ❌</h1><a href="/login">Try again</a>');
    }

    if (user.password !== password) {
      return res
        .status(401)
        .send('<h1>Invalid password ❌</h1><a href="/login">Try again</a>');
    }

    // Success
    if (userType === 'student') {
      return res.redirect(`/student/${encodeURIComponent(username)}`);
    }
    if (userType === 'teacher') {
      return res.redirect(`/teacher/${encodeURIComponent(username)}`);
    }

    return res.status(400).send('Invalid userType');
  } catch (err) {
    console.error('Login error:', err);
    return res.status(500).send('Server error');
  }
});

/* -------------------------- Student dashboard ------------------------ */
app.get('/student/:username', (req, res) => {
  const { username } = req.params;
  const courses = [
    { id: 1, name: 'Math 101' },
    { id: 2, name: 'Science 101' },
    { id: 3, name: 'History 101' },
  ];
  res.render('student_page', { username, courses });
});

// Teacher dashboard
app.get('/teacher/:username', async (req, res) => {
  try {
    const username = req.params.username;

    // Dummy assignments (replace with real DB queries later)
    const assignments = [
      { id: 1, title: 'Assignment 1', due: '2025-09-01', submissionsCount: 2 },
      { id: 2, title: 'Assignment 2', due: '2025-09-15', submissionsCount: 2 },
    ];

    // Fetch students (only userType=student)
    const students = await User.find(
      { userType: 'student' },
      { username: 1, createdAt: 1 }
    ).lean();

    // Selected assignment (via query param)
    const selectedId = parseInt(req.query.assignment || '0', 10);
    const selectedStudent = req.query.student || null;

    let selected = null;
    let analysis = null;
    // Dummy submissions (replace with DB query later)
// Dummy submissions
const allSubmissions = [
  {
    student: 'alice',
    assignmentId: 1,
    submittedAt: '2025-08-01',
    aiScore: 23,
    aiConfidence: 'low',
    aiReasoning: `The text is largely consistent with Alice's prior submissions. 
    Minor stylistic differences detected, such as slightly longer sentences. 
    Vocabulary and sentence structure match her usual patterns. 
    No significant AI-generated markers observed.`,
    fileName: 'alice_assignment1.pdf'
  },
  {
    student: 'bob',
    assignmentId: 1,
    submittedAt: '2025-08-02',
    aiScore: 82,
    aiConfidence: 'high',
    aiReasoning: `The submission uses highly structured and formal language unlike Bob's previous work. 
    Sentences are consistently long with advanced vocabulary. 
    Paragraphs are perfectly uniform in length, suggesting possible AI assistance. 
    Patterns match common AI-generated text markers, including repeated phrasing and smooth transitions.`,
    fileName: 'bob_assignment1.pdf'
  },
  {
    student: 'alice',
    assignmentId: 2,
    submittedAt: '2025-08-10',
    aiScore: 60,
    aiConfidence: 'medium',
    aiReasoning: `Some deviations in writing style detected. 
    Sentence complexity increased compared to prior submissions. 
    Vocabulary is slightly more advanced and the logical flow is smoother. 
    Possible partial AI assistance indicated.`,
    fileName: 'alice_assignment2.pdf'
  },
  {
    student: 'bob',
    assignmentId: 2,
    submittedAt: '2025-08-12',
    aiScore: 45,
    aiConfidence: 'medium',
    aiReasoning: `Text shows a mix of Bob's usual style and more sophisticated patterns. 
    Some sentences exhibit repetitive phrasing typical of AI, 
    but overall structure is still similar to past assignments.`,
    fileName: 'bob_assignment2.pdf'
  },
];

if (selectedId) {
  // Assignment-focused mode
  let filteredSubs = allSubmissions.filter(s => s.assignmentId === selectedId);

  if (selectedStudent) {
    filteredSubs = filteredSubs.filter(s => s.student === selectedStudent);
  }

  const a = assignments.find(x => x.id === selectedId) || {
    id: selectedId,
    title: `Assignment ${selectedId}`
  };
  selected = { ...a, submissions: filteredSubs };
    // Build AI analysis
  const scores = filteredSubs.map(s => Number(s.aiScore) || 0);
  const avgScore = scores.length
    ? Math.round(scores.reduce((a, b) => a + b, 0) / scores.length)
    : 0;
  const confidenceLevel =
    avgScore >= 75 ? 'high' : avgScore >= 40 ? 'medium' : 'low';
  const isAIContent =
    avgScore >= 80 ? 'likely' : avgScore >= 40 ? 'partial' : 'unlikely';
  const evidence = filteredSubs.map(s => s.aiReasoning).filter(Boolean).slice(0, 5);
  const styleDeviationDetected = filteredSubs.some(s => (s.aiScore || 0) > 50);

  analysis = {
    isAIContent,
    aiUsageScore: avgScore,
    confidenceLevel,
    styleDeviationDetected,
    evidence,
    suggestions: [
      'Ask the student to explain or reproduce parts of the work in class or through an oral exam.',
      'Compare this submission with the student’s prior assignments to check for consistency in style, vocabulary, and depth of reasoning.',
      'Look for abrupt style or formatting changes, such as sudden improvements in grammar or structure, which may indicate external assistance.',
      'Encourage the student to submit drafts or work-in-progress snapshots in the future to better track their writing process.',
      'If concerns remain, arrange a one-on-one meeting where the student explains the key arguments or calculations in detail.',
      'Consider running the text through multiple AI detection tools to confirm suspicions, but always balance with a holistic academic review.'
    ]
  };

} else if (selectedStudent) {
  // Student-focused mode
  let filteredSubs = allSubmissions.filter(s => s.student === selectedStudent);

  selected = {
    student: selectedStudent,
    submissions: filteredSubs.map(s => ({
      assignmentId: s.assignmentId,
      submittedAt: s.submittedAt,
      fileName: s.fileName,
      aiScore: s.aiScore,
      aiConfidence: s.aiConfidence,
      aiReasoning: s.aiReasoning
    }))
  };

  analysis = null;
}
    // Render page
    return res.render('teachers_page', {
      username,
      assignments,
      students,
      selected,
      analysis,
      selectedStudent
    });
  } catch (err) {
    console.error('/teacher error', err);
    return res.status(500).send('Server error');
  }
});


/* ----------------------------- Course page --------------------------- */
app.get('/student/:username/course/:courseId', (req, res) => {
  const { username, courseId } = req.params;
  const assignments = [
    { id: 1, title: 'Assignment 1' },
    { id: 2, name: 'Assignment 2' },
    { id: 3, name: 'Assignment 3' },
  ];
  res.render('course_page', { username, courseId, assignments });
});

/* -------------------------- Submission page -------------------------- */
app.get('/student/:username/course/:courseId/assignment/:assignmentId', (req, res) => {
  const { username, courseId, assignmentId } = req.params;
  res.render('submission', { username, courseId, assignmentId });
});

/* ------------------------ File upload (submit) ----------------------- */
app.post('/submit-file', upload.single('file'), async (req, res) => {
  if (!req.file) return res.status(400).send('No file uploaded');

  try {
    // Save file bytes in MongoDB
    const newFile = new File({
      filename: req.file.originalname,
      mimetype: req.file.mimetype,
      size: req.file.size,
      data: req.file.buffer,
    });

    const saved = await newFile.save();

    const viewUrl = absUrl(req, `/files/${saved._id}`);
    const inlineUrl = absUrl(req, `/files/${saved._id}/inline`);
    const dlUrl = absUrl(req, `/files/${saved._id}/download`);
    const thumbUrl = absUrl(req, `/files/${saved._id}/thumb?w=256`);

    res.send(
      `✅ File saved to MongoDB!<br>
       Name: ${saved.filename}<br>
       Size: ${saved.size} bytes<br>
       Type: ${saved.mimetype}<br>
       View: <a href="${viewUrl}">${viewUrl}</a> | ` +
      `<a href="${inlineUrl}">inline</a> | ` +
      `<a href="${dlUrl}">download</a> | ` +
      `<a href="${thumbUrl}">thumb</a>`
    );
  } catch (error) {
    console.error(error);
    res.status(500).send('❌ Error saving file to MongoDB');
  }
});

/* ------------------------------ Debug route --------------------------- */
app.get('/debug/users', async (_req, res) => {
  try {
    const dbName = mongoose.connection.name;
    const colName = mongoose.connection.collection('Login_Collection').collectionName;
    const docs = await mongoose.connection.collection('Login_Collection')
      .find({}, { projection: { username: 1, userType: 1, password: 1 } })
      .limit(50)
      .toArray();
    res.json({ db: dbName, collection: colName, count: docs.length, docs });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// NOTE: /seed-users writes EXACT values into Login_Collection of the currently connected DB.
/* --------------------------- Seed test users ------------------------- */
/* EXACT values—use once to guarantee clean docs that match exact findOne */
app.get('/seed-users', async (_req, res) => {
  try {
    const rows = [
      { username: 'alice',   password: '123',    userType: 'student' },
      { username: 'bob',     password: 'qwerty', userType: 'student' },
      { username: 'mrsmith', password: 'abc',    userType: 'teacher' },
    ];
    for (const r of rows) {
      await User.updateOne(
        { username: r.username, userType: r.userType },
        r,
        { upsert: true }
      );
    }
    res.send('Seeded users into ' + mongoose.connection.name + '/' + User.collection.collectionName);
  } catch (e) {
    console.error(e);
    res.status(500).send('Failed to seed users.');
  }
});

/* ------------------------------ Files gallery ------------------------------ */
app.get('/files', async (_req, res) => {
  try {
    const docs = await File.find({}, { filename: 1, mimetype: 1, size: 1, createdAt: 1 })
      .sort({ createdAt: -1 })
      .limit(100)
      .lean();

    const rows = docs.map(d => {
      const v = absUrl(_req, `/files/${d._id}`);
      const i = absUrl(_req, `/files/${d._id}/inline`);
      const dl = absUrl(_req, `/files/${d._id}/download`);
      const th = absUrl(_req, `/files/${d._id}/thumb?w=256`);
      return `
      <tr>
        <td>${d._id}</td>
        <td>${d.filename || ''}</td>
        <td>${d.mimetype || ''}</td>
        <td>${d.size || ''}</td>
        <td>${new Date(d.createdAt).toLocaleString()}</td>
        <td>
          <a href="${v}">view</a> |
          <a href="${i}">inline</a> |
          <a href="${dl}">download</a> |
          <a href="${th}">thumb</a>
        </td>
      </tr>
      `;
    }).join('');

    res.send(`
      <html>
        <head><title>Files (MongoDB)</title></head>
        <body>
          <h2>Files stored in MongoDB (latest 100)</h2>
          <table border="1" cellpadding="6" cellspacing="0">
            <thead>
              <tr>
                <th>_id</th>
                <th>filename</th>
                <th>mimetype</th>
                <th>size</th>
                <th>createdAt</th>
                <th>links</th>
              </tr>
            </thead>
            <tbody>
              ${rows}
            </tbody>
          </table>
        </body>
      </html>
    `);
  } catch (err) {
    console.error('GET /files error', err);
    res.status(500).send('Server error');
  }
});

/* ----------------------------- Latest file ------------------------------ */
app.get('/files/latest', async (_req, res) => {
  try {
    const doc = await File.findOne({}).sort({ createdAt: -1 });
    if (!doc) return res.status(404).send('No files');
    const buf = Buffer.isBuffer(doc.data) ? doc.data : Buffer.from(doc.data);
    res.set('Content-Type', doc.mimetype || 'application/octet-stream');
    return res.send(buf);
  } catch (err) {
    // fixed: ensure the error is logged and a 500 is returned
    console.error('GET /files/latest error', err);
    return res.status(500).send('Server error');
  }
});
/* --------------------------- Fetch by filename ---------------------------- */
app.get('/files/byname/:filename', async (req, res) => {
  try {
    const doc = await File.findOne({ filename: req.params.filename });
    if (!doc) return res.status(404).send('Not found');
    const buf = Buffer.isBuffer(doc.data) ? doc.data : Buffer.from(doc.data);
    res.set('Content-Type', doc.mimetype || 'application/octet-stream');
    return res.send(buf);
  } catch (err) {
    console.error('GET /files/byname/:filename error', err);
    return res.status(500).send('Server error');
  }
});

/* ------------------------------ All Images (gallery) ------------------------------ */
app.get('/images', async (_req, res) => {
  try {
    // Pull only image/* docs from MongoDB (Uploaded_Files collection via File model)
    const docs = await File.find(
      { mimetype: { $regex: '^image/', $options: 'i' } },
      { filename: 1, mimetype: 1, size: 1, createdAt: 1 }
    )
      .sort({ createdAt: -1 })
      .limit(1000)
      .lean();

    // Prefer thumbnails if `sharp` is available, else use the raw route
    const useThumbs = !!sharp;
    const cards = docs.map(d => {
      const href = absUrl(_req, `/files/${d._id}`);
      const thumbSrc = absUrl(_req, (useThumbs ? `/files/${d._id}/thumb?w=240` : `/files/${d._id}`));
      const title = d.filename || d._id;
      const meta = `${d.mimetype || ''} · ${d.size || 0} bytes · ${new Date(d.createdAt).toLocaleString()}`;
      return `
        <a class="card" href="${href}" title="${title}">
          <img src="${thumbSrc}" alt="${title}" loading="lazy" />
          <div class="info">
            <div class="name">${title}</div>
            <div class="meta">${meta}</div>
          </div>
        </a>
      `;
    }).join('');

    res.send(`
      <html>
        <head>
          <meta charset="utf-8" />
          <title>All Images (MongoDB)</title>
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 24px; }
            h2 { margin: 0 0 16px; }
            .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 16px; }
            .card { display: block; border: 1px solid #e5e7eb; border-radius: 8px; overflow: hidden; text-decoration: none; color: inherit; background: #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
            .card img { width: 100%; height: 160px; object-fit: cover; display: block; }
            .info { padding: 8px 10px; }
            .name { font-size: 14px; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
            .meta { font-size: 12px; color: #6b7280; margin-top: 4px; }
            .topbar { display: flex; gap: 12px; align-items: center; margin-bottom: 16px; }
            .topbar a { color: #2563eb; text-decoration: none; }
            .topbar a:hover { text-decoration: underline; }
          </style>
        </head>
        <body>
          <div class="topbar">
            <h2>All Images from MongoDB (${docs.length})</h2>
            <a href="/files">files table</a>
          </div>
          <div class="grid">
            ${cards || '<div>No images found.</div>'}
          </div>
        </body>
      </html>
    `);
  } catch (err) {
    console.error('GET /images error', err);
    res.status(500).send('Server error');
  }
});

/* ------------------------- File serving routes (MongoDB-backed) ------------------------ */
// Raw bytes (browser will render image by Content-Type)
app.get('/files/:id', async (req, res) => {
  try {
    const doc = await File.findById(req.params.id); // keep as document for Buffer
    if (!doc) return res.status(404).send('Not found');

    const buf = Buffer.isBuffer(doc.data) ? doc.data : Buffer.from(doc.data);
    res.set('Content-Type', doc.mimetype || 'application/octet-stream');
    if (doc.size) res.set('Content-Length', String(doc.size));
    return res.send(buf);
  } catch (err) {
    console.error('GET /files/:id error', err);
    return res.status(500).send('Server error');
  }
});

// Inline data-URL preview (simple HTML page)
app.get('/files/:id/inline', async (req, res) => {
  try {
    const doc = await File.findById(req.params.id);
    if (!doc) return res.status(404).send('Not found');

    const buf = Buffer.isBuffer(doc.data) ? doc.data : Buffer.from(doc.data);
    const b64 = buf.toString('base64');
    const src = `data:${doc.mimetype || 'application/octet-stream'};base64,${b64}`;
    res.send(`<html><body><h3>${doc.filename}</h3><img src="${src}" alt="${doc.filename}" /></body></html>`);
  } catch (err) {
    console.error('GET /files/:id/inline error', err);
    return res.status(500).send('Server error');
  }
});

// Force download
app.get('/files/:id/download', async (req, res) => {
  try {
    const doc = await File.findById(req.params.id);
    if (!doc) return res.status(404).send('Not found');

    const buf = Buffer.isBuffer(doc.data) ? doc.data : Buffer.from(doc.data);
    res.set('Content-Type', doc.mimetype || 'application/octet-stream');
    res.set('Content-Length', String(buf.length));
    res.set('Content-Disposition', `attachment; filename="${doc.filename || 'download'}"`);
    return res.send(buf);
  } catch (err) {
    console.error('GET /files/:id/download error', err);
    return res.status(500).send('Server error');
  }
});

// Thumbnail (requires sharp)
app.get('/files/:id/thumb', async (req, res) => {
  try {
    if (!sharp) return res.status(501).send('Thumbnailing not available: install sharp (npm i sharp)');
    const doc = await File.findById(req.params.id);
    if (!doc) return res.status(404).send('Not found');

    const buf = Buffer.isBuffer(doc.data) ? doc.data : Buffer.from(doc.data);
    const width = Math.max(1, Math.min(2048, parseInt(req.query.w || '256', 10)));

    const out = await sharp(buf).resize({ width, withoutEnlargement: true }).toBuffer();
    res.set('Content-Type', doc.mimetype || 'image/png');
    res.set('Content-Length', String(out.length));
    res.set('Cache-Control', 'public, max-age=86400');
    return res.send(out);
  } catch (err) {
    console.error('GET /files/:id/thumb error', err);
    return res.status(500).send('Server error');
  }
});

app.get('/wongweng', (req, res) => {
  const imgPath = path.join(__dirname, 'public', 'Cover.png');
  fs.access(imgPath, fs.constants.F_OK, (err) => {
    if (err) {
      return res.status(404).send('Cover.png not found in /public');
    }
    // Use absUrl to generate correct link
    const imgUrl = absUrl(req, '/Cover.png');
    res.send(`<a href="${imgUrl}">Cover Image</a><br><img src="${imgUrl}" alt="Cover Image" style="max-width:400px;">`);
  });
});

// In server.js (after connecting to MongoDB and defining User model)
app.post('/signup', async (req, res) => {
  try {
    const { name, password, confirm_password, userType } = req.body;

    // Validate required fields
    if (!name || !password || !confirm_password || !userType) {
      return res.status(400).send('All fields are required.');
    }

    // Check passwords match
    if (password !== confirm_password) {
      return res.status(400).send('Passwords do not match.');
    }

    // Check if user already exists (same username + userType)
    const existing = await User.findOne({ username: name, userType });
    if (existing) {
      return res.status(400).send(`A ${userType} account with this username already exists.`);
    }

    // Create new user
    const user = new User({
      username: name, // save username exactly as typed in the form
      password,       // plain password
      userType
    });

    await user.save();

    res.send(`✅ ${userType.charAt(0).toUpperCase() + userType.slice(1)} account created successfully!`);
  } catch (err) {
    console.error('Signup error:', err);
    res.status(500).send('Server error.');
  }
});




/* ------------------------------ Start -------------------------------- */
app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});